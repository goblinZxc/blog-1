---
layout: post
title:  "Sql"
tags:
categories:
---

## 数据库

数据库是一个以某种有组织的方式存储的数据集合(通常是一个文件或一组文件)

## 表

表是一种结构化的文件，可以用来存储某种特定类型的数据，表在数据库中是唯一的

## 模式

表具有一些特性，这些特性定义了表在数据库中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等，描述表的这组信息就是模式(scheme).

## 列

标中的一个字段，所有表都是由一个或多个列组成的

## 数据类型

每个表列都有相应的数据类型，它限制该列中存储的数据

## 行

表中的一个记录 有时候也被称为一条记录

## 主键

表中的每一行都应该有一列（或几列）可以唯一标识自己，每个表都应该有主键，方便更新和删除表中特定行

需要满足以下要求中的表中任何列都可以作为主键:

* 任意两行不具有相同的主键值
* 每一行必须具有一个主键值
* 主键列中的值不允许修改和更新
* 主键值不能重用(如果某行从表中删除，它的主键不能赋值给新增的行)

## 外键

## sql

`Strctured Query Language` 结构化查询语言，是一门和数据库沟通的语言。不同于一般的程序语言，sql中只有很少的关键字

sql 优点:

* sql不是某个特定数据库供应商专有的语言
* sql简单易学
* 灵活使用sql可以进行非常复杂和高级的数据操作

## 检索数据

* 使用换行书写的方式更易于调试
* 以分号结束每条语句
* 不区分大小写，建议大写关键字

```sql
SELECT prod_name -- prod_name, prop_id, prod_price    ||  *
FROM products;
```

```sql
SELECT DISTINCT vend_id  --不显示重复值, `DISTINCT`关键字作用于所有列
FROM products;
```


## 排列数据

```sql
SELECT prod_name
FROM products
LIMIT 5 OFFSET 5  -- 从第5行起的5行数据
ORDER BY prod_name DESC, prod_price
-- 先按照名字排序，然后 *相同*(严格相同) 名字中再按价格排序
-- 对输出进行排序  ( ORDER BY 子句要保障是最后一条子句 )
-- DESC    -- 默认按照升序排列，指定DESC按照降序排列
```

>  如果想在多个列降序，必须对每一列指定DESC关键字
>  DESC 是 DESCENDING 的缩写


## 过滤数据

```sql
SELECT prod_name,prod_price
FROM products
-- WHERE prod_price = 3.49;
-- WHERE prod_price BETWEEN 5 AND 10;
WHERE prod_city IS NULL;
-- WHERE prod_name = 'apple iphone5' 如果将值与字符串类型的列进行比较，就需要加上引号
```

操作符|说明
---|---|
=|等于
< > | 不等于
!= | 不等于
< | 小于
<= | 小于等于
!< | 不小于
> | 大于
>= | 大于等于
!> | 不大于
BETWEEN | 在指定的值之间
IS NULL | 为NULL值

## 高级过滤数据

组合`where`子句

```sql
SELECT prod_name,prod_price
FROM products
WHERE prod_name = 'iphone'
AND prod_price < 120;
```

组合时需要注意优先级，`AND`比`OR`拥有更高的优先级,可以使用括号限制优先级

```sql
SELECT prod_name,prod_price
FROM products
WHERE
( prod_name = 'iphone' OR prod_vendor =  'DELL' )
AND prod_price < 120;
```

```sql
SELECT prod_name,prod_price
FROM products
WHERE vend_id IN ('dell01','brs01');
```

使用`IN`的优点

* 合法选项多时，IN操作符更清楚直观
* 与其他AND和OR操作符组合使用IN时，求值顺序容易管理
* IN比一组OR执行更快
* IN可以包含其他SELECT语句


```sql
SELECT prod_name,prod_price
FROM products
WHERE NOT vend_id IN ('dell01','brs01');
```

## 用通配符进行过滤


```sql
SELECT  *
FROM products
WHERE prod_name
-- %代表Fish之后的任意字符
-- LIKE 'Fish%';
LIKE '%Fish%'; -- 包含Fish
LIKE 'b%@qq.com' --  找特定格式的电子邮件地址
LIKE '_____@qq.com' --  _代表一个字符
```

* 不要过度使用通配符
* 确实需要使用通配符的场景，不要把它用在搜索模式的开始处
* 注意通配符的位置

## 计算字段

存储在数据库表中的数据不一定是应用程序所需要的格式

* 需要公司名和公司地址，但这两各信息在不同的表中
* 城市 省和邮政编码存储在不同的列中，但前台程序需要一个合起来的格式
* 列数据是大小写混合的，但前台需要大写数据
* 订单表存储物品的价格和数量，但没有总价
* 需要根据表数据计算总数，平均数

> sql语句内完成的许多转换工作和格式化工作可以直接在客户端完成，不过在服务器上会更快


```sql
-- AS关键字可以创建一个别名 有时候也叫导出列
SELECT  vend_name + ' (' + vend_coutry + ')' AS vend_title
FROM products
ORDER BY vend_name
```

```sql
SELECT prod_id,quantity,item_price, quantity * item_price AS expanded_price
FROM OrderItems
WHERE order_num = 20008;
```

## 使用函数处理数据

> sql中的函数面临兼容性问题,如果使用函数，要做详细的注释

sql中的函数类型

* 处理文本字符串
* 处理数值数据
* 处理日期和时间
* 系统函数

```sql
-- 常用字符处理函数  UPPER LEFT LENGTH LEN LOWER LTRIM RTRIM SOUNDEX
SELECT vend_name , UPPER(vend_name) AS vend_name_upcase
FROM Vendors
ORDER BY vend_name
```

`SOUNDEX` 函数为一个字符串生成语音格式的字符串,例子如下

```sql
SELECT cust_name,cust_contact
FROM Customers
WHERE cust_contact = 'Michael Green';
```

数据库中存储的是发音相似但拼写错误的字符串 'Michealle Green',使用`SOUNDEX`可以查找到

```sql
SELECT cust_name,cust_contact
FROM Customers
WHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green');
```


```sql
SELECT order_num
FROM Orders
WHERE DATEPART(yy, order_date) = 2012;
```

Mysql常用数值处理函数

函数|说明
---|---|
AVG()| 返回某列的平均值
COUNT()|返回某列的行数
MAX()|返回某列的最大值
MIN()|返回某列的最小值
SUM()|返回某列值之和

> 以上5各函数都可以搭配`DISTINCT`参数

```sql

SELECT AVG(prod_price) AS avg_price
FROM Products

SELECT AVG(DISTINCT prod_price) AS avg_price
FROM Products
WHERE vend_id = 'DLL01';

SELECT COUNT(*) AS num_counts
FROM Products;

SELECT MIN(prod_price) AS min_price
FROM Products;

SELECT SUM(quantity) AS items_ordered
FROM OrderItems
WHERE order_num = 20005;

```

> 可以组合

```sql
SELECT
COUNT(*) AS num_items,
MIN(prod_price) AS price_min,
MAX(prod_price) AS price_max,
AVG(prod_price) AS price_avg
FROM
Products
```


## 分组数据

> 计算每一种商品各有多少个

```sql
SELECT vend_id, COUNT(*) AS num_prods
FROM Products
GROUP BY vend_id
```
